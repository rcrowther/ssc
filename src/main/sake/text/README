== Sake and ssc

Sake is written in Scala. You need Java.

It is a maketool. I might call it a tasker. 

== Whats a MakeTool?
Tasks, which look like methods, or proceedures, are written in code, then the overall constuction can be run/invoked in various ways.

== Why use a Tasker/Make tool?
Basicly, Make tools are one big helper for shell scripting.

You can write a book about shell scripting, but the two main advantges are,
- They do things like filemoving, which are tedious and/or nearly impossible with a computer language. And scripts are intended to be easily launchable in an operating system shell environment.
- Scripts can be used again and and again, and distributed to other interested people, unlike collections of commandline instructions.

The downside of scripting is that it is not cross-platform (at least between Unix and Windows), and involves learning another language, which is usually limited or unusual (e.g. bash).

A Make tool will offer,

- A more pliant language,
- natural and easy multitasking 
- a lot of simple helpers to do common jobs

At some cost of flexibility and power.


== Who will be interested in Sake?
Likely, only Scala users.

The host computer must have Scala installed. Scala is, once you understand, is an easy language to install. But, for running scripts, is slow and power-expensive. If you use other languages, but wish to do Rake-style jobs, try Rake. Ruby still seems to have install problems, but people will understand what you are doing and why. To use Sake is to do something weird.

One small spin --- launch is slow, but with a good side-effect. Sake is Scala. Once into the heavy lifting, Sake code is fast. Very fast.


== Pre-warnings
Sake will not install on Windows machines. You can run Sake on one, but not automatically. I can not afford a Windows computer, so can not test a .bat runner file.

== Lets sum it up

Bad,
- No Windows support
- Painfully slow launch - 2 secs
- API changes with every release
- Amateur code
- No JLine
- No infrastructure
- Lack of test coverage
- Clumbersome DSL

Good
- Fast at heavy jobs
- You're writing in Scala
- You wouldn't try it in Java

Rake is not Make, despite the promotional descriptions. And Sake is not like Rake or Make. If you were hoping for Rake-in-Scala, you will be disappointed. Sake goes it's own way.




== How do you say it?
It should be "say'k'" like "Make". But where I come from, saying it like Japanese rice wine, "saaa'kay'", is both legitimate, and a good joke.

=== Versions
Its on version 0.6 or something. That's because Sake is a long way off a settled public API, and has changed much already.

Expect it to keep changing. Settled API = version 1.0.


== Using Sake embedded in other code
It's a class. It can multitask and hump data round an operating system, and with some helpers, probably route some other data like streams. It could be useful for commandline programs which reorganise/structure operating system data. See below for more info.

== Using the runner
When the runner, and thus an instance of Sake, is installed, Sake scripts can be run from anyplace in the operating system. The next instructions are about that.

== Building code
I don't like build tools, and have no base to distribute Java .jar files. So building is by hand.

You need Java and Scala.

For Java, OpenJDK is fine, and can be installed by package. Or download an Oracle jar file and put it someplace. For Scala, packages are not so reliable. Scala has always moved fast, and packaging doesn't keep up. Sake and SSC use simple Scala code, so should work even with old versions of Scala. On the whole, a download of Scala may cause less problems. Then put it on your path. Urrgh. See below, follow same instructions as installing Sake itself.
 
Right, the main event. Download Sake/ssc, and navigate a terminal into the top folder. Then,

scalac @scalacArgs

That will send the terminal wild with enthusiasm, at the end of which, you have a compile. It's in the folder/directory named 'sake'.

Then make executable .jar files from the code,

scala -verbose -toolcp sake -Dsake.runner.home= sake.PackageSake installable


If all runs ok, a folder called sake-<some.version.name> should appear inside the folder. It has a /bin and a /lib in it. You can half-install it.


=== Reminder instructions for a half-install
Move the entire /bin folder to wherever you keep Java code, and put them on your computer's path.

Adjust the top of the Sake script to point at your choice of Scala installation (and Sake and Java, if you wish).

Change Path
-----------
To put a folder in the operating systems $PATH, so the commandline can find it. To see your path,

echo $PATH

Find .bashrc, usually in your home folder. If you have a Debian-based system it depends on the development philosophy one long-ago frosty morning. Try  ~/.bash_profile. Or even just creating .bashrc and see if it works. Or swapping operting sytems for someone that will tell you what they are doing.

Add or ammend like this (note the lack of spaces. bash is not fond of spaces),

PATH=/home/someUserName/Websites/someSiteFolder:$PATH

or use,

/etc/profile

for all users. 

The path declaration needs,

export path

after that, but many more complex config files (e.g. Debian) have that already.

 
(you can export 

PATH=$PATH:/home/someUserName/Websites/someSiteFolder

, but it won't persist)


Restart bash
-------------

source ~/.bashrc

or restart the whole computer, but in the middle of development, that's a right pain.


=== Adjust the script
The Sake script launcher doesn't try to 'scala' the jar, it runs Java with Scala as a library (more flexible).

You need to tell the script where to find Scala. In the script, point this variable,
 
SCALA_HOME="/path/to/my/chosen/scala/folder"

at the folder containing the Scala executables (it should contain /lib and /bin).

Don't be tempted to add formatting, especially spaces! This is BASH! It will scorn you!

You can also point at another Java, in the same way, using,

JAVA_HOME="/path/to/my/chosen/jdk"

...and change the Sake you are using, but most people will not need that.

=== Put the scripts on the path



== Using Sake
== Quick try
I hate installation, so if you've go this far, try this.

Make an empty folder. 

Make a file called Test.sake and paste this in,



import sake.util.{Dir, Entry}

// A sake to create files
Test
extends Sake
with sake.utils.Runner
{
  protected task("fileMadeBySakeDependancy.txt") {
    val p = cwd.resolve("doc")
    File.create(p)
  }

  task("createFileInDir" after("dirMadeBySake")) {
    val p = cwd.resolve("doc")
    Dir.create(p)
  }

  task("createFile") {
    val p = cwd.resolve("fileMadeBySake.txt")
    File.create(p)
  }
}

Use a terminal and navivate in. Now, in the terminal, run (in any order),

sake createDir

sake createFileInDir

Files should appear.

New users can get a lot from this,
- Try running again. 
Nothing will happen. These are one-off tasks. If everything is in place, sake won't waste CPU or memory by trying again.

- Try cleaning the files out and running again
The files will reappear.

- Try running sake fileMadeBySakeDependancy
Won't work. The task is protected. However, it is run by createFileInDir - the code in the task is a "dependancy" or "prerequisite".

- The console will print that one or two threads are used
From the commandline launcher, Sake naturally uses threads.

Rake users may spot,
- Sake doesn't have fancy tasks. 
Tasks are generic. You write code inside them.

And for everyone
- Try runnng with sake --invoke createFileInDir
The code reports no threads are used. That's because no threads are created, the thread that calls does the work.


== Guide to sake
Please look at the scaladoc. There is also package documentation.

=== Using the Runner
The runner is a shell script which invokes a small piece of Scala code. This finds and runs files in the System postfixed with the file extension ".sake".

When installed, the runner hunts for files in the current folder (current working directory) of the terminalwhich invokes it.

It uses the first file with the extension ".sake". If there are multiple ".sake" files, the runner will make an undetermined choice. There is no way to define a target file. The best solution is to move interfering files out of the way, at least temporarily.

==== The runner cache
The runner maintains a cache of compiled scripts.

This is completely against the grain of scripting, and the feature exists because of Scala. Being a compiled language, its a miracle Scala can even run a commandline, and it is slow to launch. However, with Sake, and due to the cache, this slow launch only happens once. Subsequent runs are very fast.

The author find this  useful. However, it does involve some design compromises. All Sake files intended for the runner must be namespaced, or they will clash in the cache. And the cache itself needs maintenance, using reserved words.


=== Maintaining the cache
Some switches are used for cache maintenance, at the time of writing,

  -cacheClear                     empty the cache
  -cacheList                      list the classes in the cache

== Making a sake file for the Runner
The file must be named after the class within. The Java convention revisited. Sorry, but it makes sense here.

The file must have the extension ".sake" 

Inside, the class (named after the base of the filename) should extend from one of the SakeRunner classes. There are a few of these now. Mostly, the more advanced ones handle the argument input and parsinbg for you, at the expense of flexibility. See the Scaladoc for more information on each one.

== File and classnames
- The classname must match the filename.
- The classname must be distinctive, otherwise the sake may refuse to compile, also running a previously compiled sake with the same name.

(a quick solution to this is to clear the cache)


== Packaging
Sakes for runners can have packaging declared. Sake can handle the compile and run. However, packaging or not, Sake runner files must have distinct names, or compiled code will clash (the only way Sake knows the name and packaging of your class is from the filename - it doesn't parse the file).
 

=== Making a sake do something - tasks

Inside you can write tasks, and the tasks can have dependancies.

In Make and Rake, the tasks themselves are customised to do activities,

Bash:

Rake:

In Sake they are not. There are only two tasks (the author has a poor memory), the stubTask, which has a name, description and works as a stub, and the do-something task,

taskEmpty()

task() {
...something happens
}

To make anything happen, use the helpers

=== Making a sake do something - utils
Helpers are anything that make the grim job of operating system (mainly) interaction easier.

They could be written any way, and Sake's current set are there by interest and as a current guess. Have a look at Scaladoc to see where Sake is up to.

Sake's largest set of helpers, by far, are the file helpers. These are not reciever-notated, they are object-based (huh, Java). The only novelty is that a `regular` file (i.e. not a directory/symlink) is called an Entry. They are all Path-based (so, assuming the URLs here listed are Paths),

Dir.readEntry("/some/directory/")
Returns the paths of all regular files in the  given directory

Entry.delete("/some/regular/file.mine") 
Deletes that file

You get the idea?

There's a couple of shell invokation helpers, mimicing Rake's convention,

sh("touch", /new/regular/file.mine")

Though Scala is cute by itself,

Seq("touch", /new/regular/file.mine") !!

Have a look through Scaladoc.


== Writing a custom Sake - more on the insides
== Running
Sake can be run by several methods, but at base there are two, `invoke` and `evoke`. `invoke` uses no threads, `evoke` uses one thread for each provied task.

Note that `evoke` does not use threads for each dependancy. It starts a thread (or thread) for each base task it is given. As each task has dependancies resolved, the starter thread is used.

There are two ways to further control the running. An option can be given to the runner, `multitaskDependancies`. This canses all dependancies to be run in seperate threads.

Also, a sake can run the dependancies of one task as threads. Like this,

  task("createFile", multitaskDependancies = true, after("createFile", "createFile2")) {
    val p = cwd.resolve("fileMadeBySake.txt")
    File.create(p)
  }

This will only run the one set of dependancies with a seperate thread.

The overall option `multitaskDependancies` will override the individual task declarations, and make all tasks run with threaded dependancies.


=== Sakes and threads
Sakes can run more than one thread at once, but can not be *voked by several threads at once. They carry shared class data. They are a class for a reason --- if you need more than one running at once, create a new instance. Otherwise, the options and output will become confused (Rake is like this too).


== Run options
For the full list of options, see the scaladoc for the class VokeOptions. For first time users, "verbose" may have some interest.

Run options can be supplied through the code api or, if using the runner, through the commandline or a SakeFile.txt.

== Output
Sake has has a crude method of handling stream output (but crude is good for scripts, no?). There is a protected value,

trace("hideous unfixed error!!")

Otuputs to stdout in a consistent way. Also,

trace.verbose("Dire warning of future!!")

will print only if the 'verbose' option is set (through the commandline, or in a SakeFile.txt).

If you need to set verbose yourself, (probably best not to override Sake runner handling, but ok for your own work),

trace.verbose = true/false

will do that.


=== Stopping a Sake
==== Using Exceptions
If the user is a computer person, and a Sake is intended to do a one-off set of tasks e.g. `install/uninstall` or `update`, then the best way to stop Sake is by throwing an exception. Java will tidy up running threads. Also, Sake catches all runtime exceptions and has a good set of reporting tools (already, derived from Rake and adapted for Java exceptions). It has options like "--cause", "--backtrace", and "--verbose" which can be specified in a SakeFile.txt or through the commandline.  The options "--cause" and "--backtrace" together ask Sake to report on the cause of an exception and print it's backtrace (not the backtrace from Sake, but from the excepting code).

This is the general approach of Rake and, for a computer person, this will be very informative.


==== Handling Exceptions
Stopping-by-exception is not so useful if a Sake is to be embedded or used as a general purpose application. On the whole, users should not be seeing exceptions, the code should be handling exceptions and printing useful messages. Also, if a sake is to be JLined, or in some other way run repeatedly, then an abrupt stop is not appropriate.

Sake generates exceptions not from builtin tasks, but from it's helper methods (Sake itself should {i never} throw an exception). So, at some cost of coding, the helper methods have extra versions, which catch exceptions. These are all prefixed by "NoThrow" e.g.


Sakes NoThrow helper methods have various returns, usually an Option (None means the helper executed - beware, this is the reverse of usual, and a Some() would contain an Exception) or sometimes an Either.

Note that the general intention for a Sake is that tasks have a do-or-throw-exception (die) design. If exceptions are trapped by yourself, or a NoThrow* handler, the coder becomes resposible for handling execution flow. Route errors, error messsages, and thrown Exceptions must be written. It's more effort but, for a friendly interface, may be worth the time.

See also returns.

=== The runner, and passing commandline options in
If Sake is installed, or half-installed, so it runs from the commandline, it uses a runner. This is a small script which launches the code. Most Java installs have something like this.

The runner makes a nice clean interface, gathers the position of the runner (hard to do otherwise in Java), and asssembles arguments. Runner data is passed by Java system propeties and, for consistency, is accessed by helper methods, so a SakeFile.txt needs this, 

Sake
extends sake.utils.Runner
{
    // Current executable directory (where the Sake runner is placed)
    val ced: Path = getCed()
    // Current working directory (where the Sake runner was launched from)
    val cwd: Path = getCwd()
    // The args passed to a runner command( as a sequence of fragments e.g. "-d", "/home/sammy/bin" etc.)
    val args: Seq[String] = getArgs
}

A Sake will run through the runner without the Runner class extension, but the resulting class will have no access to this data (so, for example, cannot modify files in the place where the sake was launched).


=== Continuous argument loading
If a Sake is kept alive (using JLine, for example), it can carry useful data, such as tasks sucessfully completed.

To introduce new commandline arguments, from a user command or cron job, say, reset the Java system property,

System.setProperties("sake.runner.args")

?
Or, if the args are not from a commandline, make your own setters and methods,

def specialRun(args: Seq[String])
{
...
}

Sake has no code nor opinion on these matters.


== More on input options
Similar code to Sake has a concept of `environment variables'. These are variables passed in. Sake has no such concept. First, genuine injections of environmental data are done using Java system properties. Second, if the user wishes to input some initial data, Scala makes it easy,

MySake(
val someEnvironment: Hills,
val someMoreEnvironment: Lakes
)
extends Sake
{
...
}

no problem.


== Passing data about code
Make and Rake are made for scripting in the operating system. They, like Sake, have tasks based in a do-or-throw-exception (die) design. As a result, they often do not to need to pass data about,

task("temp:create") {
Dir.create(cwd.resolve("tmp"))
}

task("temp:populate", after("temp:create")) {
Entry.copy(cwd.resolve("photos"), cwd.resolve("tmp"))
}

"temp:populate" depends on "temp:create", and asssumes the directory is there. If directory creation fails, an exception halts the "temp:populate" thread. For a script, this is neat and low on coding.

If data needs to be passed from task to task, the class can have a variable, or maybe the Make code provides some environmental data where it can be loaded. Sake has another way; tasks return a value. Like methods in the the programming languages Ruby and Scala, methods {i always} return a value.

The value returned is an Any, and the Any is in a Map, because tasks can have several dependancies. So a return value is an effort to unwrap. It looks like this,

task("temp:read") {
Dir.read(cwd.resolve("tmp"))
}

task("temp:handle", after("temp:read")) {
// illustrating the return type
val ret : Map[String, Any] = returns
val paths = ret("temp:read").asInstanceOf[TraversableDir[Path]]
...
}


task("temp:handleConcisely", after("temp:read")) {
val paths = returns("temp:read").asInstanceOf[TraversableDir[Path]]
...
}


While returns are nasty to unwrap, they can make for some good code. First, return values are only available inside tight scopes (like programming language methods or proceedures). Also, inside tasks, returns are cached. So,

task("temp:read") {
Dir.read(cwd.resolve("tmp"))
}

task("temp:handle", after("temp:read")) {
val paths = returns("temp:read").asInstanceOf[TraversableDir[Path]]
...
}

Not only will this code get a list of paths from the directory "tmp" but, if the Sake is multitasking or run continually inside fsc, "temp:read" will only read the directory once. Thereafter, the "temp:read" task caches the return, and returns it's cache. 


== Invoking tasks directly
Sake tasks can be invoked/evoked anyplace in code. No need for a dependancy, nor even embedding in another task --- they can be called from inside a method,

BedtimeSake
extends Sake
{
task("putLightsOut") {
...
"dark"
}
def goToBed(dring: Drink) {
val r : Map[String, Any] = task("putLightsOut")
println(r("putLightsOut").asInstanceOf[String])
}
}

Run,

> new BedtimeSake.goToBed()
  dark

Note the `invoke` return has the same format as the `returns` parameter in a task.

The big use for dependancies is to make multitasking explicit. Otherwise, an `invoke` or `evoke` will do the job.




 



